name: Kaniko Build

on:
  workflow_call:
    inputs:
      registry_url:
        required: true
        type: string
      registry_cache_url:
        required: false
        type: string
      name:
        required: true
        type: string
      dockerfile:
        type: string
        default: "./Dockerfile"
      cache:
        type: boolean
        default: true
      push:
        type: boolean
        default: false
      tag:
        default: ""
        type: string
    secrets:
      registry_username:
        required: true
      registry_password:
        required: true

jobs:
  build:
    runs-on: ${{ vars.RUNNER }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build with in-cluster buildkit job (large context)
        env:
          REGISTRY_URL: ${{ inputs.registry_url }}
          REGISTRY_USERNAME: ${{ secrets.registry_username }}
          REGISTRY_PASSWORD: ${{ secrets.registry_password }}
          IMAGE_NAME: ${{ inputs.name }}
          IMAGE_TAG: ${{ inputs.tag }}
          DOCKERFILE: ${{ inputs.dockerfile }}
          PUSH_ENABLED: ${{ inputs.push }}
        run: |
          set -euo pipefail

          IMAGE_REF="${REGISTRY_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
          JOB_NAME="buildkit-$(date +%s)-${RANDOM}"
          NAMESPACE="${ACTIONS_RUNNER_POD_NAMESPACE:-arc-runners}"

          echo "Building: ${IMAGE_REF}"

          # Create docker config for registry auth
          mkdir -p /tmp/kaniko
          cat > /tmp/kaniko/config.json <<EOF
          {
            "auths": {
              "${REGISTRY_URL}": {
                "username": "${REGISTRY_USERNAME}",
                "password": "${REGISTRY_PASSWORD}"
              }
            }
          }
          EOF

          # Pack build context (uses .dockerignore if present)
          tar czf /tmp/context.tar.gz --exclude-vcs -C "${GITHUB_WORKSPACE}" .

          # Create secret for docker config
          kubectl create secret generic ${JOB_NAME}-creds \
            --from-file=config.json=/tmp/kaniko/config.json \
            -n ${NAMESPACE}

          # Create build Job (emptyDir for context + workspace)
          cat <<'EOF' | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${JOB_NAME}
            namespace: ${NAMESPACE}
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 0
            template:
              spec:
                serviceAccountName: github-runner
                restartPolicy: Never
                initContainers:
                - name: wait-for-context
                  image: busybox:1.36
                  command: ['sh', '-c', 'i=0; while [ $i -lt 120 ]; do if [ -f /context/context.tar.gz ]; then exit 0; fi; sleep 2; i=$((i+1)); done; echo "context missing" >&2; exit 1']
                  volumeMounts:
                  - name: context
                    mountPath: /context
                - name: extract-context
                  image: busybox:1.36
                  command: ['sh', '-c', 'mkdir -p /workspace && chmod 777 /workspace && tar xzf /context/context.tar.gz -C /workspace']
                  volumeMounts:
                  - name: context
                    mountPath: /context
                  - name: workspace
                    mountPath: /workspace
                containers:
                - name: buildkit
                  image: moby/buildkit:rootless
                  env:
                  - name: DOCKER_CONFIG
                    value: /docker-config
                  - name: BUILDKITD_FLAGS
                    value: --oci-worker-no-process-sandbox
                  command: ["/bin/sh", "-c"]
                  args:
                  - |
                    set -e
                    buildctl-daemonless.sh build \
                      --frontend dockerfile.v0 \
                      --local context=/workspace \
                      --local dockerfile=/workspace \
                      --opt filename=${DOCKERFILE} \
                      --output type=image,name=${IMAGE_REF},push=${PUSH_ENABLED}
                  volumeMounts:
                  - name: workspace
                    mountPath: /workspace
                  - name: docker-config
                    mountPath: /docker-config
                  resources:
                    limits:
                      memory: "5Gi"
                      cpu: "2"
                volumes:
                - name: context
                  emptyDir: {}
                - name: workspace
                  emptyDir: {}
                - name: docker-config
                  secret:
                    secretName: ${JOB_NAME}-creds
          EOF

          echo "Job created: ${JOB_NAME}"

          # Wait for pod to be in Running state, then copy context (requires pods/exec RBAC)
          for i in $(seq 1 60); do
            POD_NAME=$(kubectl get pods -n ${NAMESPACE} -l job-name=${JOB_NAME} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            POD_PHASE=$(kubectl get pod/${POD_NAME} -n ${NAMESPACE} -o jsonpath='{.status.phase}' 2>/dev/null || true)
            if [ "${POD_PHASE}" = "Running" ] || [ "${POD_PHASE}" = "Pending" ] || [ "${POD_PHASE}" = "ContainerCreating" ]; then
              if [ -n "${POD_NAME}" ]; then
                kubectl cp /tmp/context.tar.gz ${NAMESPACE}/${POD_NAME}:/context/context.tar.gz -c wait-for-context && break
              fi
            fi
            sleep 2
          done

          echo "Streaming build logs..."
          kubectl logs -f job/${JOB_NAME} -n ${NAMESPACE} || true

          # Cleanup
          kubectl delete job/${JOB_NAME} secret/${JOB_NAME}-creds -n ${NAMESPACE}
