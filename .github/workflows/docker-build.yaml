name: Kaniko Build

on:
  workflow_call:
    inputs:
      registry_url:
        required: true
        type: string
      registry_cache_url:
        required: false
        type: string
      name:
        required: true
        type: string
      dockerfile:
        type: string
        default: "./Dockerfile"
      cache:
        type: boolean
        default: true
      push:
        type: boolean
        default: false
      tag:
        default: ""
        type: string
    secrets:
      registry_username:
        required: true
      registry_password:
        required: true

jobs:
  build:
    runs-on: ${{ vars.RUNNER }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build with Kaniko Job
        env:
          REGISTRY_URL: ${{ inputs.registry_url }}
          REGISTRY_USERNAME: ${{ secrets.registry_username }}
          REGISTRY_PASSWORD: ${{ secrets.registry_password }}
          IMAGE_NAME: ${{ inputs.name }}
          IMAGE_TAG: ${{ inputs.tag }}
          DOCKERFILE: ${{ inputs.dockerfile }}
          CACHE_ENABLED: ${{ inputs.cache }}
          CACHE_REPO: ${{ inputs.registry_cache_url }}
          PUSH_ENABLED: ${{ inputs.push }}
        run: |
          set -euo pipefail

          JOB_NAME="buildkit-$(date +%s)-${RANDOM}"
          NAMESPACE="${ACTIONS_RUNNER_POD_NAMESPACE:-arc-runners}"
          IMAGE_REF="${REGISTRY_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
          CACHE_IMAGE="${CACHE_REPO:+${CACHE_REPO}/cache}"

          echo "Building: ${IMAGE_REF}"

          # Create docker config
          mkdir -p /tmp/kaniko
          cat > /tmp/kaniko/config.json <<EOF
          {
            "auths": {
              "${REGISTRY_URL}": {
                "username": "${REGISTRY_USERNAME}",
                "password": "${REGISTRY_PASSWORD}"
              }
            }
          }
          EOF

          # Create tarball of source
          tar czf /tmp/context.tar.gz -C ${GITHUB_WORKSPACE} .

          # Create secret for credentials only
          kubectl create secret generic ${JOB_NAME}-creds \
            --from-file=config.json=/tmp/kaniko/config.json \
            -n ${NAMESPACE}

          # BuildKit cache flags (registry-based)
          CACHE_FLAGS=""
          if [ "${CACHE_ENABLED}" = "true" ] && [ -n "${CACHE_IMAGE}" ]; then
            CACHE_FLAGS="--export-cache type=registry,ref=${CACHE_IMAGE},mode=max --import-cache type=registry,ref=${CACHE_IMAGE}"
          fi

          # Create Job with emptyDir volume (no size limit)
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${JOB_NAME}
            namespace: ${NAMESPACE}
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 0
            template:
              spec:
                serviceAccountName: github-runner
                restartPolicy: Never
                initContainers:
                - name: prepare-context
                  image: busybox:1.36
                  command: ['sh', '-c', 'mkdir -p /workspace && chmod 777 /workspace']
                  volumeMounts:
                  - name: workspace
                    mountPath: /workspace
                containers:
                - name: buildkit
                  image: moby/buildkit:rootless
                  env:
                  - name: DOCKER_CONFIG
                    value: /docker-config
                  - name: BUILDKITD_FLAGS
                    value: --oci-worker-no-process-sandbox
                  securityContext:
                    appArmorProfile:
                      type: Unconfined
                  command: ["/bin/sh", "-c"]
                  args:
                  - |
                    set -e
                    tar xzf /context/context.tar.gz -C /workspace
                    buildctl-daemonless.sh build \
                      --frontend dockerfile.v0 \
                      --local context=/workspace \
                      --local dockerfile=/workspace \
                      --opt filename=${DOCKERFILE} \
                      --output type=image,name=${IMAGE_REF},push=${PUSH_ENABLED} \
                      ${CACHE_FLAGS}
                  volumeMounts:
                  - name: context
                    mountPath: /context
                  - name: workspace
                    mountPath: /workspace
                  - name: docker-config
                    mountPath: /docker-config
                  resources:
                    limits:
                      memory: "5Gi"
                      cpu: "2"
                volumes:
                - name: context
                  emptyDir:
                    sizeLimit: 5Gi
                - name: workspace
                  emptyDir:
                    sizeLimit: 10Gi
                - name: docker-config
                  secret:
                    secretName: ${JOB_NAME}-creds
          EOF

          echo "Job created: ${JOB_NAME}"
          echo "Uploading build context..."
          
          # Wait for pod to be ready
          sleep 3
          POD_NAME=$(kubectl get pods -l batch.kubernetes.io/job-name=${JOB_NAME} -n ${NAMESPACE} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          # Copy the tarball into the pod's context volume
          if [ -n "$POD_NAME" ]; then
            kubectl cp /tmp/context.tar.gz ${NAMESPACE}/${POD_NAME}:/context/context.tar.gz -c buildkit || true
          fi

          echo "Waiting for Job to start..."
          sleep 5

          # Stream logs while job is running
          kubectl logs -f job/${JOB_NAME} -n ${NAMESPACE} 2>/dev/null &
          LOG_PID=$!

          # Wait for either completion or failure
          while true; do
            JOB_STATUS=$(kubectl get job/${JOB_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}' 2>/dev/null || echo "")
            JOB_FAILED=$(kubectl get job/${JOB_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}' 2>/dev/null || echo "")
            
            if [ "$JOB_STATUS" = "True" ]; then
              wait ${LOG_PID} 2>/dev/null || true
              echo "Build complete!"
              kubectl delete job/${JOB_NAME} secret/${JOB_NAME}-creds -n ${NAMESPACE}
              break
            elif [ "$JOB_FAILED" = "True" ]; then
              wait ${LOG_PID} 2>/dev/null || true
              echo "Build failed! Job status:"
              kubectl get job/${JOB_NAME} -n ${NAMESPACE} -o yaml | grep -A 10 "status:"
              echo ""
              echo "Pod status:"
              kubectl get pods -l batch.kubernetes.io/job-name=${JOB_NAME} -n ${NAMESPACE}
              POD_NAME=$(kubectl get pods -l batch.kubernetes.io/job-name=${JOB_NAME} -n ${NAMESPACE} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
              if [ -n "$POD_NAME" ]; then
                echo ""
                echo "Pod describe:"
                kubectl describe pod/${POD_NAME} -n ${NAMESPACE} || true
                echo ""
                echo "Last 50 lines of pod logs:"
                kubectl logs ${POD_NAME} -n ${NAMESPACE} --tail=50 || true
              fi
              echo ""
              echo "Last 50 lines of logs:"
              kubectl logs job/${JOB_NAME} -n ${NAMESPACE} --tail=50
              kubectl delete job/${JOB_NAME} secret/${JOB_NAME}-creds -n ${NAMESPACE}
              exit 1
            fi
            
            sleep 5
          done
