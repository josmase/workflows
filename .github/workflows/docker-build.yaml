name: Kaniko Build

on:
  workflow_call:
    inputs:
      registry_url:
        required: true
        type: string
      registry_cache_url:
        required: false
        type: string
      name:
        required: true
        type: string
      dockerfile:
        type: string
        default: "./Dockerfile"
      cache:
        type: boolean
        default: true
      push:
        type: boolean
        default: false
      tag:
        default: ""
        type: string
    secrets:
      registry_username:
        required: true
      registry_password:
        required: true

jobs:
  build:
    runs-on: ${{ vars.RUNNER }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build with Kaniko Job
        env:
          REGISTRY_URL: ${{ inputs.registry_url }}
          REGISTRY_USERNAME: ${{ secrets.registry_username }}
          REGISTRY_PASSWORD: ${{ secrets.registry_password }}
          IMAGE_NAME: ${{ inputs.name }}
          IMAGE_TAG: ${{ inputs.tag }}
          DOCKERFILE: ${{ inputs.dockerfile }}
          CACHE_ENABLED: ${{ inputs.cache }}
          CACHE_REPO: ${{ inputs.registry_cache_url }}
          PUSH_ENABLED: ${{ inputs.push }}
        run: |
          set -euo pipefail

          JOB_NAME="kaniko-$(date +%s)"
          NAMESPACE="${ACTIONS_RUNNER_POD_NAMESPACE:-arc-runners}"
          IMAGE_REF="${REGISTRY_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
          
          echo "Building: ${IMAGE_REF}"
          
          # Create docker config
          mkdir -p /tmp/kaniko
          cat > /tmp/kaniko/config.json <<EOF
          {
            "auths": {
              "${REGISTRY_URL}": {
                "username": "${REGISTRY_USERNAME}",
                "password": "${REGISTRY_PASSWORD}"
              }
            }
          }
          EOF
          
          # Create tarball of source
          tar czf /tmp/context.tar.gz -C ${GITHUB_WORKSPACE} .
          
          # Create secrets/configmaps
          kubectl create secret generic ${JOB_NAME}-creds \
            --from-file=config.json=/tmp/kaniko/config.json \
            -n ${NAMESPACE}
          
          kubectl create configmap ${JOB_NAME}-context \
            --from-file=context.tar.gz=/tmp/context.tar.gz \
            -n ${NAMESPACE}
          
          # Build args
          ARGS="--dockerfile=${DOCKERFILE} --context=/workspace --destination=${IMAGE_REF}"
          [ "${CACHE_ENABLED}" = "true" ] && [ -n "${CACHE_REPO}" ] && ARGS="${ARGS} --cache=true --cache-repo=${CACHE_REPO}/cache"
          [ "${PUSH_ENABLED}" = "false" ] && ARGS="${ARGS} --no-push"
          
          # Create Job
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${JOB_NAME}
            namespace: ${NAMESPACE}
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 0
            template:
              spec:
                serviceAccountName: github-runner
                restartPolicy: Never
                initContainers:
                - name: extract
                  image: busybox:1.36
                  command: ['sh', '-c', 'tar xzf /context/context.tar.gz -C /workspace']
                  volumeMounts:
                  - name: context
                    mountPath: /context
                  - name: workspace
                    mountPath: /workspace
                containers:
                - name: kaniko
                  image: gcr.io/kaniko-project/executor:v1.23.2
                  args: 
                  - ${ARGS}
                  volumeMounts:
                  - name: workspace
                    mountPath: /workspace
                  - name: docker-config
                    mountPath: /kaniko/.docker
                  resources:
                    limits:
                      memory: "2Gi"
                      cpu: "2"
                volumes:
                - name: context
                  configMap:
                    name: ${JOB_NAME}-context
                - name: workspace
                  emptyDir: {}
                - name: docker-config
                  secret:
                    secretName: ${JOB_NAME}-creds
          EOF
          
          # Wait for completion
          kubectl wait --for=condition=complete job/${JOB_NAME} -n ${NAMESPACE} --timeout=1h || {
            kubectl logs -l batch.kubernetes.io/job-name=${JOB_NAME} -n ${NAMESPACE}
            kubectl delete job/${JOB_NAME} secret/${JOB_NAME}-creds configmap/${JOB_NAME}-context -n ${NAMESPACE}
            exit 1
          }
          
          echo "Build complete!"
          kubectl delete secret/${JOB_NAME}-creds configmap/${JOB_NAME}-context -n ${NAMESPACE}
